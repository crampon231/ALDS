# ALDS
Algorithms and Data Structures in Python3  
[プログラミングコンテスト攻略のためのアルゴリズムとデータ構造(マイナビ出版)](https://www.amazon.co.jp/プログラミングコンテスト攻略のためのアルゴリズムとデータ構造-渡部-有隆/dp/4839952957)をPython3で  
[AOJ](http://judge.u-aizu.ac.jp/onlinejudge/index.jsp)

## ソート
- 計算量と安定性
- データを保持する配列以外にメモリが必要か
- 入力データの特徴が計算量に影響するか

### 挿入ソート
ALDS_1_1_A
- 安定
- O(n^2)
- ある程度整列されたデータには高速に動作

### バブルソート
ALDS_1_2_A
- 安定
- O(n^2)
- バブルソートの交換回数は反転数または転倒数と呼ばれ、列の乱れ具合を表す

### 選択ソート
ALDS_1_2_B
- 非安定
- O(n^2)

### シェルソート
ALDS_1_3_D
- 改良挿入ソート
- 非安定
- g_{n+1} = 3g_n + 1を使うと O(n^1.25)くらい

### マージソート
ALDS1_5_B
- 安定
- O(nlogn)
- 一時的にO(n)の記憶領域が必要

### パーティション
ALDS1_6_B
- O(n)

### クイックソート
ALDS1_6_C
- パーティションを繰り返してソートする
- 非安定
- インプレースソート(追加のメモリ領域を必要としない)
- 平均計算量O(nlogn)で、一般に最も高速なソートアルゴリズム
- 基準のとり方に工夫

### 計数ソート
ALDS1_6_A
- バケツソート, バケットソート
- 各要素が0以上k以下の長さnの数列に対してO(n+k)
- 安定
- 追加の記憶領域が必要

## データ構造
データ構造は
- データの集合
- 規則
- 操作  
からなる。

### キュー
ALDS1_3_B  
リングバッファを実装。
普段は`collections.deque`を使うのが良さそう。

### 連結リスト
ALDS1_3_C, ALDS1_3_C_2  
自分で書いたものは遅い...。

## 探索
### 線形探索
ALDS1_4_A
- O(n)
- 番兵を置くことで定数倍の高速化ができる

### 二分探索
ALDS1_4_B
- O(logn)
- 整列している場合に使用可

## 分割統治
- 与えられた問題を部分問題に分割する
- 部分問題を再帰的に解く
- 得られた部分問題の解を統合し、もとの問題を解く

## 木構造

### 探索木
探索木は、挿入、検索、削除などの操作が行えるデータ構造で、辞書あるいは優先度付きキューとして用いることができる。  
最も基本的なものが二分探索木。(ALDS1_8_A)  
挿入、検索、削除とも、木の高さをhとするとO(h)の計算量になる。  
ノード数nに対して、木のバランスが悪いと高さがnに近くなり、計算量も大きくなる。  
これを防ぐため、木の高さがlognくらいになるようにしているものを平衡二分探索木という。  
これなら計算量がO(logn)になる。
pythonでの計算量は<https://qiita.com/Hironsan/items/68161ee16b1c9d7b25fb>  
がまとめている。

## ヒープ
### 二分ヒープ
二分ヒープは、木の各節点に割り当てられたキーが１つの配列の各要素に対応した完全二分木で表されたデータ構造。
優先度付きキューが簡単に実装できる。
pythonならheapqを使うといい。

## 動的計画法
小さい部分問題の解をメモリに記憶しておいて、大きい問題の解を計算するために有効利用する。

## グラフ
グラフにおける最も基本的なアルゴリズムが探索。
グラフの探索とは、グラフの全ての頂点（または部分的な頂点の集合）を体系的に訪問すること。
訪問のしかたによって、グラフの様々な特徴を調べることができる。

### 隣接行列表現
#### 長所
- M[u][v]で辺(u,v)を参照できるので、頂点u,vの関係をO(1)で確認できる。
- M[u][v]を変更することで辺の追加・削除を簡単かつ効率的に行える。(O(1))
#### 短所
- 頂点数の2乗に比例するメモリを消費する。特に辺の数が少ないグラフ（疎なグラフ）ではメモリを無駄にする。
- 1つの隣接行列では、頂点u,vの関係を1つしか記録できない。

### 隣接リスト表現
#### 長所
- 辺の数に比例したメモリした必要としない。
#### 短所
- 頂点u,vの関係を調べるには、uに隣接する頂点の数をnとして、O(n)のリストを探索する必要がある。ただし、DFSやBFSでは順番にたどる場合が多いため、あまり問題にはならない。
- 辺の削除を効率的に行うことが難しい。

### 深さ優先探索
行けるところまでとことん行く探索。
スタックや再帰を使って簡易に実装できる。
隣接リストを用いた深さ優先探索はO(|V|^2)になるので、隣接リストを使った実装が高速。
また、大きなグラフに対する再帰を用いた深さ優先探索は、言語や環境によってはスタックオーバーフローを起こす可能性がある。


### 幅優先探索
既に探索した頂点と未探索の頂点の境界を幅いっぱいに渉って拡張しながら行う探索。

### プリムのアルゴリズム
最小全域木を求めるアルゴリズム。素朴な実装では、グラフの頂点数をnとするとO(n^2)の計算量になる。
二分ヒープを使って頂点を決定するようにすれば高速化(O(|E|log|V|))できる。

### クラスカルのアルゴリズム
GRL_2_A  
辺の重みでソートし、閉路ができないように小さい方から選んでいく。ソートに一番時間がかかり、O(|E|log|E|)のアルゴリズムになる。


### ダイクストラのアルゴリズム
最短経路木を求めるアルゴリズム。素朴な実装では、グラフの頂点数をnとするとO(n^2)の計算量になる。
負の重みを持つ場合には使えないことに注意。その場合にはBellman FordやWarshall Floydのアルゴリズムを使う。

### 互いに素な集合
DSL_1_A  
Disjoint Sets Forestsと呼ばれる森の構造でDisjoint Setsを実装する。経路圧縮とrankを用いた実装ではO(logn)より高速になる。

### 領域探索
DSL_2_C  
kD Treeを構築する。点をソートして中央値をノードとして二分木を構築していく。k>1の場合は、ソートする基準を構築する木の深さによって変えていく。  
点の数をnとすると、木の構築についてはO(nlogn)のソートを木の高さlogn回行うので、O(nlog^2n)のアルゴリズムになる。領域探索は指定された領域内に含まれる点の数をk, kD木の木の次元をdとするとO(n^(1-1/d)+ k)のアルゴリズムになる。

### All Pairs Shortest Path
GRL_1_C  
全点対間最短経路問題(All Pairs Shortest Path, APSP)はグラフG=(V, E)に対して、Gに含まれる頂点の全ての組の最短経路を求める問題。
Gに負の重みのある辺がなければ、各頂点を始点としてダイクストラのアルゴリズムを|V|回行うことで解ける。
オリジナルの実装ではO(|V|^3)、優先度付きキューを用いたものではO(|V|(|E|+|V|)log|V|)になる。  
負の重みがある場合でも、負の閉路がなければワーシャルフロイドのアルゴリズムでO(|V|^3)で解ける。
ワーシャルフロイドのアルゴリズムは、最短経路だけでなく、負の閉路が存在するかを判定できる。
