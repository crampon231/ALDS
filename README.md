# ALDS
Algorithms and Data Structures

## ソート
- 計算量と安定性
- データを保持する配列以外にメモリが必要か
- 入力データの特徴が計算量に影響するか

### 挿入ソート
ALDS_1_1_A
- 安定
- O(n^2)
- ある程度整列されたデータには高速に動作

### バブルソート
ALDS_1_2_A
- 安定
- O(n^2)
- バブルソートの交換回数は反転数または転倒数と呼ばれ、列の乱れ具合を表す

### 選択ソート
ALDS_1_2_B
- 非安定
- O(n^2)

### シェルソート
ALDS_1_3_D
- 改良挿入ソート
- 非安定
- g_{n+1} = 3g_n + 1を使うと O(n^1.25)くらい

### マージソート
ALDS1_5_B
- 安定
- O(nlogn)
- 一時的にO(n)の記憶領域が必要

### パーティション
ALDS1_6_B
- O(n)

### クイックソート
ALDS1_6_C
- パーティションを繰り返してソートする
- 非安定
- インプレースソート(追加のメモリ領域を必要としない)
- 平均計算量O(nlogn)で、一般に最も高速なソートアルゴリズム
- 基準のとり方に工夫

### 計数ソート
ALDS1_6_A
- バケツソート, バケットソート
- 各要素が0以上k以下の長さnの数列に対してO(n+k)
- 安定
- 追加の記憶領域が必要

## データ構造
データ構造は
- データの集合
- 規則
- 操作  
からなる。

### キュー
ALDS1_3_B  
リングバッファを実装。
普段は`collections.deque`を使うのが良さそう。

### 連結リスト
ALDS1_3_C, ALDS1_3_C_2  
自分で書いたものは遅い...。

## 探索
### 線形探索
ALDS1_4_A
- O(n)
- 番兵を置くことで定数倍の高速化ができる

### 二分探索
ALDS1_4_B
- O(logn)
- 整列している場合に使用可

## 分割統治
- 与えられた問題を部分問題に分割する
- 部分問題を再帰的に解く
- 得られた部分問題の解を統合し、もとの問題を解く

## 木構造

### 探索木
探索木は、挿入、検索、削除などの操作が行えるデータ構造で、辞書あるいは優先度付きキューとして用いることができる。  
最も基本的なものが二分探索木。(ALDS1_8_A)  
挿入、検索、削除とも、木の高さをhとするとO(h)の計算量になる。  
ノード数nに対して、木のバランスが悪いと高さがnに近くなり、計算量も大きくなる。  
これを防ぐため、木の高さがlognくらいになるようにしているものを平衡二分探索木という。  
これなら計算量がO(logn)になる。
pythonでの計算量は<https://qiita.com/Hironsan/items/68161ee16b1c9d7b25fb>  
がまとめている。